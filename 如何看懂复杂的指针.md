# 如何看懂复杂的指针

指针大家都学过了，简单的指针相信大家都不放在眼里，就不再赘述，但是复杂的你能理解吗？能理解指针就学的差不多了，至于如何运用只要你看懂指针就知道应该给它赋什么值，怎么用。

+ 首先咱们一起来看看这个： `int (*fun)(int *p)`
  + 首先需要分析这个是不是一个指针，如果是，是什么指针？如果不是，那是什么？
  + 1. 根据(*fun)可知，fun是一个指针
    2. 然后看fun的后面是一个函数参数列表，可以确定是一个指向函数的指针
    3. 指向的函数的返回值是什么类型呢，再回头看看最前面发现是一个int
    4. 最后我们可以根据这个函数指针写出对应的函数

结果如下:

```c
int foo(int *p)
{
    reutrn 0;
}
```



## 右左法则

上面我们分析了一个函数指针，那结果是如何得出来的呢？全靠经验吗，NO，其实是有方法的。

这个方法叫做**右左法则**：

+ 右左法则不是C标准里面的内容，它是从C标准的声明规定中归纳出来的方法。C标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的。

+ 右左法则使用：
  + 1. 首先从最里面的圆括号(应该是标识符)看起，然后往右看，再往左看;
    2. 每当遇到圆括号时，就应该调转阅读方向；
    3. 一旦解析完圆括号里面所有东西，就跳出圆括号；
    4. 重复这个过程知道整个声明解析完毕。



## 案例走起

#### 1.int (\*p[5])(int\*)

解析：

1. 从标识符p开始，p先与[]结合形成一个数组，然后与*结合，表示是一个指针数组；
2. 然后跳出这个圆括号，往后看，发现了一个函数的参数列表，说明数组里面装的是函数指针；
3. 在跳出圆括号，往前看返回类型，可以确定函数指针的类型。

#### 2. int (\*fun)(int \*p,int (\*pf)(int \*))

解析：

1. fun与*结合形成指针；
2. 往后看是一个参数列表，说明是一个函数指针，只不过参数里面还有一个函数指针；
3. 往前看可以确定函数指针的返回类型。

#### 3. int (\*(\*fun)[5])(int \*p)

解析：

1. fun与*结合，形成指针；
2. 往后看发现了一个[5]说明是一个指向数组的指针；
3. 再往前看，发现有一个*,说明数组里面存的是指针；
4. 跳出圆括号往后看，发现了参数列表，说明数组里面存的是函数指针；
5. 再往前看可以确定函数指针的返回类型。

![image-20220120185734595](E:/GitHub/course/C语言从入门到放弃/13 指针之字符串/assets/image-20220120185734595.png)

#### 4. int (\*(\*fun)(int \*p))[5]

解析：

1. fun与*结合，形成指针；

2. 往后看发现了参数列表，说明fun是一个函数指针；

3. 往前看遇到了*说明，函数指针的返回类型是一个指针，是什么指针继续往后解析；

4. 往后看发现了[5] 说明是一个数组指针，最前面一个int，说明fun这个函数指针的返回类型是一个数组的指针

   类型为int (*)[5]

   ![image-20220120185709724](E:/GitHub/course/C语言从入门到放弃/13 指针之字符串/assets/image-20220120185709724.png)

#### 5. int(\*(\*fun())())()

解析：

1. fun与()结合，说明fun是一个函数；
2. 往前看发现了一个*，说明函数返回类型为指针，什么指针呢？
3. 往后看发现了参数列表，fun函数返回的是一个函数指针，那这个函数指针的返回类型是什么呢？
4. 往前看又发现了一个*,说明函数指针返回类型也是一个指针，那这个指针是什么指针呢?
5. 往后看又发现了一个参数列表，说明是个函数指针，往前看这个函数指针返回的是int类型

![image-20220120185628198](E:/GitHub/course/C语言从入门到放弃/13 指针之字符串/assets/image-20220120185628198.png)

## 总结

实际当中，需要声明一个复杂指针时，如果把整个声明写成上面所示的形式，对程序可读性是一大损害。应该用typedef来对声明逐层分解，增强可读性



**指针变量有两种类型：**指针变量的类型和指针所指向的对象的类型

指针变量的类型
只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

+ int\* ptr;	//指针的类型是int\*
+ char\* ptr;	//指针的类型是char\*
+ int\** ptr;	//指针的类型是int**
+ int(\*ptr)[3];	//指针的类型是int(\*)[3]

+ int\*(\*ptr)[4];	//指针的类型是int\*(\*)[4]

指针变量指向的对象的类型

+ 你只须把指针声明语句中的指针名字和名字左边的指针声明符\*去掉，剩下的就是指针所指向的类型。
  + int\*ptr; 	//指针所指向的类型是int
  + char\*ptr;	 //指针所指向的的类型是char
  + int\*\*ptr; 	//指针所指向的的类型是int\*
  + int(\*ptr)[3]; 	//指针所指向的的类型是int()[3]
  + int\*(\*ptr)[4]; 	//指针所指向的的类型是int\*()[4]



**注意事项:**

+ 指针变量也是变量，也有存储空间，存的是别的变量的地址。

  + 要注意指针的值，和指向的对象的值得区别

  + 普通变量中的内存空间存放的是，数值或字符等。 ----直接存取

  + 指针变量中的内存空间存放的是，另外一个普通变量的地址。----间接存取

    

+ 连续定义多个指针变量时，容易犯错误，比如：int *p,p1;只有p是指针变量，p1是整型变量

+ 避免使用为初始化的指针，很多运行错误都是由于这个原因导致的，而且这种错误又不能被编译器检查所以很难被发现，解决方法：初始化为NULL，报错就能很快找到原因

+ 指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，操作指针是才能知道按什么类型去操作

+ 在用动态分配完内存之后一定要判断是否分配成功，分配成功后才能使用。

+ 在使用完之后一定要释放，释放后必须把指针置为NULL